Secure Dialer-style Chat + AV App

This single-file project includes a React client (Vite) and a Node.js signaling server (Socket.io). Copy files into a project folder, follow the README steps below to run locally, and deploy to HTTPS + TURN for production.


---

README

Overview

Client: React (single-file example). UI looks like a phone-dialer icon and contains chat + audio/video call.

Server: Node.js + Express + Socket.io used for signaling and simple JWT auth placeholder.

Media: WebRTC (getUserMedia + RTCPeerConnection). WebRTC uses DTLS/SRTP for encrypted media. For NAT traversal you must add a TURN server (coturn) in production.


Files included in this single snippet

client/ (React app): App.jsx, index.html, vite.config.js, package.json (client-only deps)

server/ (Node.js): server.js, package.json, .env.example



---

client/src/App.jsx

import React, { useEffect, useRef, useState } from 'react';
import io from 'socket.io-client';

// Change to your signaling server URL (https) when deploying
const SIGNALING_SERVER = import.meta.env.VITE_SIGNALING_URL || 'http://localhost:4000';

export default function App(){
  const localVideoRef = useRef();
  const remoteVideoRef = useRef();
  const pcRef = useRef(null);
  const socketRef = useRef(null);
  const [joined, setJoined] = useState(false);
  const [roomId, setRoomId] = useState('');
  const [messages, setMessages] = useState([]);
  const [text, setText] = useState('');
  const dataChannelRef = useRef(null);

  useEffect(()=>{
    socketRef.current = io(SIGNALING_SERVER, { transports: ['websocket'] });

    socketRef.current.on('connect', ()=>{
      console.log('connected to signaling');
    });

    socketRef.current.on('offer', async ({ from, sdp })=>{
      await ensurePeerConnection();
      await pcRef.current.setRemoteDescription(sdp);
      const answer = await pcRef.current.createAnswer();
      await pcRef.current.setLocalDescription(answer);
      socketRef.current.emit('answer', { to: from, sdp: pcRef.current.localDescription });
    });

    socketRef.current.on('answer', async ({ sdp })=>{
      await pcRef.current.setRemoteDescription(sdp);
    });

    socketRef.current.on('ice-candidate', async ({ candidate })=>{
      try{ await pcRef.current.addIceCandidate(candidate); }catch(e){ console.warn(e); }
    });

    socketRef.current.on('chat', ({ from, text })=>{
      setMessages(m=>[...m, { from, text }]);
    });

    return ()=>{ socketRef.current.disconnect(); };
  }, []);

  async function ensurePeerConnection(){
    if(pcRef.current) return;

    const pc = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        // add TURN in production: { urls: 'turn:YOUR_TURN_SERVER', username:'user', credential:'pass' }
      ]
    });

    pcRef.current = pc;

    pc.ontrack = (evt)=>{
      if(remoteVideoRef.current) remoteVideoRef.current.srcObject = evt.streams[0];
    };

    pc.onicecandidate = (e)=>{
      if(e.candidate){
        socketRef.current.emit('ice-candidate', { candidate: e.candidate, room: roomId });
      }
    };

    // Data channel for chat
    const dc = pc.createDataChannel('chat');
    dataChannelRef.current = dc;
    dc.onmessage = (e)=>{ setMessages(m=>[...m, { from: 'peer', text: e.data }]); };

    pc.ondatachannel = (ev)=>{
      ev.channel.onmessage = (e)=>{ setMessages(m=>[...m, { from: 'peer', text: e.data }]); };
    };

    // local stream
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
    if(localVideoRef.current) localVideoRef.current.srcObject = stream;
    stream.getTracks().forEach(track=>pc.addTrack(track, stream));
  }

  async function createRoom(){
    await ensurePeerConnection();
    const offer = await pcRef.current.createOffer();
    await pcRef.current.setLocalDescription(offer);
    socketRef.current.emit('offer', { room: roomId, sdp: pcRef.current.localDescription });
    setJoined(true);
  }

  async function joinRoom(){
    await ensurePeerConnection();
    socketRef.current.emit('join', { room: roomId });
    setJoined(true);
  }

  function sendChat() {
    if(dataChannelRef.current && dataChannelRef.current.readyState === 'open'){
      dataChannelRef.current.send(text);
      setMessages(m=>[...m, { from: 'me', text }]);
      setText('');
    } else {
      // fallback: server relay
      socketRef.current.emit('chat', { room: roomId, text });
      setMessages(m=>[...m, { from: 'me', text }]);
      setText('');
    }
  }

  function hangup(){
    pcRef.current?.getSenders().forEach(s=>s.track?.stop());
    pcRef.current?.close();
    pcRef.current = null;
    setJoined(false);
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
      <div className="w-full max-w-3xl bg-white rounded-2xl shadow p-4 grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="md:col-span-2">
          <div className="flex items-center gap-4">
            {/* Dialer-like icon */}
            <div className="w-16 h-16 rounded-full bg-blue-600 flex items-center justify-center text-white text-xl font-bold">ðŸ“ž</div>
            <div>
              <input className="border p-2 rounded w-64" placeholder="Room ID" value={roomId} onChange={e=>setRoomId(e.target.value)} />
              <div className="mt-2 flex gap-2">
                <button className="px-3 py-1 rounded bg-green-500 text-white" onClick={createRoom}>Create & Call</button>
                <button className="px-3 py-1 rounded bg-indigo-500 text-white" onClick={joinRoom}>Join</button>
                <button className="px-3 py-1 rounded bg-red-500 text-white" onClick={hangup}>Hangup</button>
              </div>
            </div>
          </div>

          <div className="mt-4 grid grid-cols-2 gap-2">
            <video ref={localVideoRef} autoPlay muted playsInline className="w-full rounded" style={{background:'#000'}} />
            <video ref={remoteVideoRef} autoPlay playsInline className="w-full rounded" style={{background:'#000'}} />
          </div>
        </div>

        <div className="p-2 border rounded">
          <div className="h-64 overflow-auto p-2">
            {messages.map((m,i)=>(
              <div key={i} className={`mb-2 ${m.from==='me'? 'text-right':''}`}>
                <div className="inline-block p-2 rounded bg-gray-100">{m.from}: {m.text}</div>
              </div>
            ))}
          </div>
          <div className="mt-2 flex gap-2">
            <input className="flex-1 border p-2 rounded" value={text} onChange={e=>setText(e.target.value)} placeholder="Message" />
            <button className="px-3 py-1 rounded bg-blue-600 text-white" onClick={sendChat}>Send</button>
          </div>
        </div>
      </div>
    </div>
  );
}


---

client/index.html (vite)

<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Secure Dialer App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

client/src/main.jsx

import React from 'react'
import { createRoot } from 'react-dom/client'
import App from './App'
import './index.css'

createRoot(document.getElementById('root')).render(<App />)

client/package.json (example)

{
  "name":"dialer-client",
  "version":"1.0.0",
  "private":true,
  "scripts":{
    "dev":"vite",
    "build":"vite build",
    "preview":"vite preview"
  },
  "dependencies":{
    "react":"^18.0.0",
    "react-dom":"^18.0.0",
    "socket.io-client":"^4.0.0"
  },
  "devDependencies":{
    "vite":"^4.0.0"
  }
}


---

server/server.js

require('dotenv').config();
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const jwt = require('jsonwebtoken'); // optional: use for auth

const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*' } });

const JWT_SECRET = process.env.JWT_SECRET || 'change_this_in_prod';

// Simple middleware for token check (expand for real auth)
function verifyToken(token){
  try{ return jwt.verify(token, JWT_SECRET); }catch(e){ return null; }
}

io.on('connection', socket=>{
  console.log('socket connected', socket.id);

  socket.on('join', ({ room, token })=>{
    // Example: check token
    // const user = verifyToken(token);
    socket.join(room);
    socket.data.room = room;
    socket.emit('joined', { room });
  });

  socket.on('offer', ({ room, sdp })=>{
    // broadcast to others in room
    socket.to(room).emit('offer', { from: socket.id, sdp });
  });

  socket.on('answer', ({ to, sdp })=>{
    io.to(to).emit('answer', { sdp });
  });

  socket.on('ice-candidate', ({ candidate, room })=>{
    socket.to(room).emit('ice-candidate', { candidate });
  });

  socket.on('chat', ({ room, text })=>{
    socket.to(room).emit('chat', { from: socket.id, text });
  });

  socket.on('disconnect', ()=>{ console.log('disconnect', socket.id); });
});

const PORT = process.env.PORT || 4000;
server.listen(PORT, ()=> console.log('Signaling server listening on', PORT));

server/package.json

{
  "name":"dialer-server",
  "version":"1.0.0",
  "main":"server.js",
  "dependencies":{
    "express":"^4.18.0",
    "socket.io":"^4.5.0",
    "dotenv":"^16.0.0",
    "jsonwebtoken":"^9.0.0"
  }
}

server/.env.example

PORT=4000
JWT_SECRET=change_this_to_secure_value


---

Security & Production Recommendations

1. Serve everything over HTTPS (TLS). Use a valid SSL cert (Letâ€™s Encrypt).


2. Use a TURN server (coturn) with credentials to ensure connectivity and prevent direct IP exposure in some networks. Add TURN to the iceServers list.


3. Use JWT or session auth so only authorized users can join a room. Validate tokens on the server before allowing join. Rotate keys.


4. Use secure headers, CORS policy, rate-limiting and logging on server.


5. For stronger end-to-end encryption of messages, consider adding an E2EE layer (e.g., use libs implementing Double Ratchet) â€” by default WebRTC provides encrypted media (DTLS/SRTP) but signaling and data channel may be relayed by TURN.


6. Deploy signaling server behind HTTPS and protect with firewall rules.




---

How to run locally (quick)

1. Install Node.js 18+.


2. Create two folders: client and server and paste the respective code.


3. In server: npm install, create .env from .env.example, node server.js.


4. In client: npm install, set VITE_SIGNALING_URL in .env if needed, npm run dev.


5. Open client, enter same room ID on two devices/tabs and click Create & Call / Join.




---

Deployment suggestions

Host server on Render / DigitalOcean / AWS with HTTPS.

Use Vercel/Netlify for client (set VITE_SIGNALING_URL to server URL).

Use managed TURN or host coturn and add credentials.



---

Notes

This example is intentionally simple and educational. For production, strengthen auth, add persistent user management, and use TURN + HTTPS.

If you want, I can also generate a ready-to-deploy GitHub repo structure and a Vercel/Render deploy guide.


