import React, { useEffect, useMemo, useRef, useState } from "react"; import { motion, AnimatePresence } from "framer-motion"; import { Card, CardContent } from "@/components/ui/card"; import { Button } from "@/components/ui/button"; import { Input } from "@/components/ui/input"; import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";

// --- Firebase (optional cloud backend) --- // Supply real config to enable Google sign-in + cloud leaderboard. // 1) Create a Firebase project → Web App → Copy config // 2) Replace placeholders below OR load from env // 3) Enable Authentication (Google or Anonymous) + Firestore import { initializeApp, getApps } from "firebase/app"; import { getAuth, GoogleAuthProvider, signInWithPopup, signOut as fbSignOut, onAuthStateChanged, signInAnonymously } from "firebase/auth"; import { getFirestore, collection, addDoc, query, orderBy, limit, onSnapshot, serverTimestamp } from "firebase/firestore";

const firebaseEnabled = typeof window !== "undefined" && !!(import.meta?.env?.VITE_FIREBASE_API_KEY || (window).FIREBASE_API_KEY); const firebaseConfig = { apiKey: import.meta?.env?.VITE_FIREBASE_API_KEY || (window).FIREBASE_API_KEY || "", authDomain: import.meta?.env?.VITE_FIREBASE_AUTH_DOMAIN || (window).FIREBASE_AUTH_DOMAIN || "", projectId: import.meta?.env?.VITE_FIREBASE_PROJECT_ID || (window).FIREBASE_PROJECT_ID || "", storageBucket: import.meta?.env?.VITE_FIREBASE_STORAGE_BUCKET || (window).FIREBASE_STORAGE_BUCKET || "", messagingSenderId: import.meta?.env?.VITE_FIREBASE_MESSAGING_SENDER_ID || (window).FIREBASE_MESSAGING_SENDER_ID || "", appId: import.meta?.env?.VITE_FIREBASE_APP_ID || (window).FIREBASE_APP_ID || "", };

let app = null, auth = null, db = null; if (firebaseEnabled) { if (!getApps().length) app = initializeApp(firebaseConfig); else app = getApps()[0]; auth = getAuth(app); db = getFirestore(app); }

/**

Crash Game — Pro Demo (No Real Money)

Upgrades in this version:

✅ Mobile-first responsive UI

✅ Rich graph (Canvas)

✅ Sounds, particle celebration

✅ Lightweight login (username) + local profile

✅ Local leaderboard (top wins)

✅ Cloud leaderboard (Firestore) — optional

✅ Google/Anonymous sign-in (if Firebase config provided)

✅ "Pseudo" multi-user via BroadcastChannel + optional WS client

✅ PWA hooks (service worker + manifest examples)

🚧 Sample Node.js WS server in comments

⚠️ Educational demo. Fake coins only. No gambling/payments. */


import { useCallback } from "react";

// --- Utility helpers --- const randHex = (len = 64) => [...crypto.getRandomValues(new Uint8Array(len / 2))] .map(b => b.toString(16).padStart(2, "0")).join("");

async function sha256(text) { const enc = new TextEncoder(); const buf = await crypto.subtle.digest("SHA-256", enc.encode(text)); return [...new Uint8Array(buf)].map(b => b.toString(16).padStart(2, "0")).join(""); }

function hashToUnitFloat(hash) { const slice = hash.slice(0, 13); // 52 bits const int = parseInt(slice, 16); const max = Math.pow(2, 52); return int / max; // [0,1) }

function crashFromHash(hash) { const r = Math.max(1e-12, hashToUnitFloat(hash)); let crash = 1 / (1 - r); crash = Math.min(crash, 1000); return Math.max(1.0, Math.floor(crash * 100) / 100); }

function formatMoney(n) { return n.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }); }

// --- PWA (register service worker if available) --- function registerServiceWorker() { if (typeof window !== "undefined" && "serviceWorker" in navigator) { navigator.serviceWorker.register("/sw.js").catch(() => {}); } }

// --- Sounds --- function useSfx() { const ctxRef = useRef(null); const ensureCtx = () => { if (!ctxRef.current) ctxRef.current = new (window.AudioContext || window.webkitAudioContext)(); return ctxRef.current; }; const beep = (freq = 880, dur = 0.07) => { try { const ctx = ensureCtx(); const o = ctx.createOscillator(); const g = ctx.createGain(); o.type = "sine"; o.frequency.value = freq; g.gain.value = 0.001; // start quiet (mobile-safe) o.connect(g); g.connect(ctx.destination); const now = ctx.currentTime; g.gain.exponentialRampToValueAtTime(0.08, now + 0.01); g.gain.exponentialRampToValueAtTime(0.0001, now + dur); o.start(); o.stop(now + dur + 0.02); } catch { /* ignore */ } }; return { start: () => beep(620, 0.12), cashout: () => beep(1100, 0.18), crash: () => beep(220, 0.25), click: () => beep(840, 0.05), }; }

// --- Particle burst on cashout --- function ParticleBurst({ triggerKey }) { const [p, setP] = useState([]); useEffect(() => { if (!triggerKey) return; const arr = Array.from({ length: 22 }).map(() => ({ id: crypto.randomUUID(), x: Math.random() * 100, y: Math.random() * 30 + 35, s: Math.random() * 0.8 + 0.4, d: Math.random() * 60 + 40, })); setP(arr); const t = setTimeout(() => setP([]), 1200); return () => clearTimeout(t); }, [triggerKey]); return ( <div className="pointer-events-none absolute inset-0 overflow-hidden"> {p.map(pt => ( <span key={pt.id} className="absolute rounded-full bg-white/70 shadow" style={{ left: ${50}%, top: ${50}%, width: ${pt.s * 8}px, height: ${pt.s * 8}px, transform: translate(-50%, -50%), animation: burst 1.1s ease-out forwards }} /> ))} <style>{@keyframes burst{0%{opacity:1;transform:translate(-50%,-50%) scale(0.6)}100%{opacity:0;transform:translate(-50%,-220%) scale(1)}}}</style> </div> ); }

// --- Canvas Graph --- function useCanvasGraph(multiplier, target, state) { const ref = useRef(null); useEffect(() => { const c = ref.current; if (!c) return; const dpr = window.devicePixelRatio || 1; const w = c.clientWidth, h = c.clientHeight; c.width = Math.floor(w * dpr); c.height = Math.floor(h * dpr); const ctx = c.getContext("2d"); ctx.scale(dpr, dpr); ctx.clearRect(0,0,w,h); // axes ctx.globalAlpha = 0.6; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(36, h-26); ctx.lineTo(w-12, h-26); ctx.stroke(); ctx.beginPath(); ctx.moveTo(36, h-26); ctx.lineTo(36, 12); ctx.stroke(); // target dash ctx.setLineDash([6,6]); const yTarget = h - 26 - (Math.min(target, 12) - 1) / 11 * (h - 48); ctx.beginPath(); ctx.moveTo(36, yTarget); ctx.lineTo(w-12, yTarget); ctx.stroke(); ctx.setLineDash([]); // line const maxX = w - 48; const maxY = h - 48; const x = Math.min(maxX, (multiplier - 1) / (target - 1 || 1) * maxX); const y = maxY - (multiplier - 1) / (Math.min(target, 12) - 1 || 1) * maxY; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(36, h-26); ctx.lineTo(36 + x, 26 + y); ctx.stroke(); // label ctx.fillStyle = "#fff"; ctx.globalAlpha = 1; ctx.font = "bold 16px ui-monospace, SFMono-Regular"; ctx.fillText(${multiplier.toFixed(2)}x, 44 + x, 20 + y); }, [multiplier, target, state]); return ref; }

// --- BroadcastChannel (pseudo multi-user across tabs) --- const bc = typeof window !== "undefined" && "BroadcastChannel" in window ? new BroadcastChannel("crash-demo") : null;

// --- Optional WebSocket client (pair with server sample in About tab) --- function useWsSync(setRoundInfo, setState, setMultiplier) { useEffect(() => { // Auto-connect only in dev / localhost to avoid unwanted traffic in prod const shouldConnect = location.hostname === "localhost" || location.hostname === "127.0.0.1"; if (!shouldConnect) return; let ws = new WebSocket("ws://localhost:8080"); ws.onmessage = (e) => { try { const m = JSON.parse(e.data); if (m.type === "round" && m.round) setRoundInfo(m.round); if (m.type === "start") setState("running"); if (m.type === "crash") setState("crashed"); if (m.type === "hello" && m.round) setRoundInfo(m.round); } catch {} }; ws.onclose = () => { ws = null; }; return () => { try { ws?.close(); } catch {} }; }, [setRoundInfo, setState, setMultiplier]); }

export default function CrashGamePro() { // Auth/Profile (local + optional Firebase) const [user, setUser] = useState(() => { const raw = localStorage.getItem("cg_user"); return raw ? JSON.parse(raw) : null; });

// Firebase auth sync (optional) useEffect(() => { if (!auth) return; return onAuthStateChanged(auth, (u) => { if (u) { const name = u.displayName || u.isAnonymous ? (user?.name || "Guest") : (user?.name || ""); setUser({ name: name || u.email || "Player", uid: u.uid, photo: u.photoURL || null }); } }); }, []);

const signInGoogle = async () => { if (!auth) return alert("Firebase not configured"); try { await signInWithPopup(auth, new GoogleAuthProvider()); } catch (e) { console.error(e); } }; const signInAnon = async () => { if (!auth) return alert("Firebase not configured"); try { await signInAnonymously(auth); } catch (e) { console.error(e); } }; const signOutCloud = async () => { try { await fbSignOut(auth); } catch {} setUser(null); };

const sfx = useSfx();

// Core state const [balance, setBalance] = useState(() => Number(localStorage.getItem("cg_balance") || 1000)); const [bet, setBet] = useState(50); const [state, setState] = useState(/** @type {"idle"|"countdown"|"running"|"crashed"} */("idle")); const [multiplier, setMultiplier] = useState(1); const [roundInfo, setRoundInfo] = useState({ serverSeed: "", clientSeed: "", nonce: 0, hash: "", crashPoint: 1.0 }); const [myBet, setMyBet] = useState(null); const [cashoutAt, setCashoutAt] = useState(null); const [countdown, setCountdown] = useState(3); const [lastCashKey, setLastCashKey] = useState(0);

const rafRef = useRef(0); const startTsRef = useRef(0);

// Persist useEffect(() => { localStorage.setItem("cg_balance", String(balance)); }, [balance]); useEffect(() => { if (user) localStorage.setItem("cg_user", JSON.stringify(user)); }, [user]);

// Prepare round const prepareRound = async (prevNonce = 0) => { const serverSeed = randHex(64); const clientSeed = randHex(16); const nonce = prevNonce + 1; const preimage = ${serverSeed}:${clientSeed}:${nonce}; const hash = await sha256(preimage); const crashPoint = crashFromHash(hash); const ri = { serverSeed, clientSeed, nonce, hash, crashPoint }; setRoundInfo(ri); bc?.postMessage({ type: "round", ri }); };

useEffect(() => { prepareRound(); registerServiceWorker(); }, []); useWsSync(setRoundInfo, setState, setMultiplier);

// Game permissions const canBet = state === "idle" || state === "countdown"; const canStart = state === "idle" && myBet !== null; const canCash = state === "running" && myBet !== null && cashoutAt === null;

// Graph hook const canvasRef = useCanvasGraph(multiplier, roundInfo.crashPoint, state);

// Game loop const step = (ts) => { if (startTsRef.current === 0) startTsRef.current = ts; const t = (ts - startTsRef.current) / 1000; const target = roundInfo.crashPoint; const growth = 1 + 0.6 * t + 0.12 * t * t; // smooth-ish curve const next = Math.min(target, growth); setMultiplier(Math.max(1, Math.round(next * 100) / 100)); if (next >= target) { cancelAnimationFrame(rafRef.current); setState("crashed"); sfx.crash(); if (myBet && cashoutAt === null) setMyBet(null); // lost bet bc?.postMessage({ type: "crash" }); } else { rafRef.current = requestAnimationFrame(step); } };

// Actions const startRound = async () => { if (!myBet) return; setState("countdown"); for (let i = 3; i > 0; i--) { setCountdown(i); await new Promise(r => setTimeout(r, 650)); } setState("running"); setMultiplier(1); setCashoutAt(null); startTsRef.current = 0; sfx.start(); rafRef.current = requestAnimationFrame(step); bc?.postMessage({ type: "start" }); };

const placeBet = () => { if (!canBet) return; const amt = Math.max(1, Math.floor(Number(bet))); if (amt > balance) return alert("Not enough balance"); setBalance(b => b - amt); const bobj = { amount: amt, by: user?.name || "Guest" }; setMyBet(bobj); sfx.click(); bc?.postMessage({ type: "bet", bet: bobj }); };

const onWinRecorded = async (name, win, at) => { // Local board always saveToLeaderboard(name, win, at); // Cloud board if Firebase enabled try { if (db) { const ref = collection(db, "wins"); await addDoc(ref, { name, win: Number(win.toFixed(2)), at: Number(at.toFixed(2)), ts: serverTimestamp() }); } } catch (e) { console.error("cloud save failed", e); } };

const cashOut = () => { if (!canCash) return; const win = Math.floor(myBet.amount * multiplier * 100) / 100; setCashoutAt(multiplier); setBalance(b => b + win); setLastCashKey(Date.now()); sfx.cashout(); onWinRecorded(user?.name || "Guest", win, multiplier); bc?.postMessage({ type: "cashout", at: multiplier, win }); };

const nextRound = async () => { cancelAnimationFrame(rafRef.current); setState("idle"); setMultiplier(1); setCashoutAt(null); await prepareRound(roundInfo.nonce); bc?.postMessage({ type: "idle" }); };

// Cross-tab sync (pseudo multi-user) useEffect(() => { if (!bc) return; const onMsg = (ev) => { const m = ev.data; if (m.type === "round") setRoundInfo(m.ri); if (m.type === "start") { setState("running"); setMultiplier(1); } if (m.type === "crash") setState("crashed"); if (m.type === "idle") { setState("idle"); setMultiplier(1); } }; bc.addEventListener("message", onMsg); return () => bc.removeEventListener("message", onMsg); }, []);

const profitThisRound = useMemo(() => { if (!myBet) return 0; if (state === "running" && cashoutAt === null) return myBet.amount * (multiplier - 1); if (cashoutAt !== null) return myBet.amount * (cashoutAt - 1); if (state === "crashed" && cashoutAt === null) return -myBet.amount; return 0; }, [state, multiplier, myBet, cashoutAt]);

// Local username auth fallback const signInLocal = (name) => { const u = { name: name.trim().slice(0, 20) || "Guest" }; setUser(u); };

return ( <div className="min-h-screen w-full flex items-center justify-center bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950 p-3"> <Card className="w-full max-w-4xl bg-white/5 backdrop-blur border-slate-700/50 shadow-2xl"> <CardContent className="p-4 sm:p-6">

{/* Header */}
      <div className="flex items-center justify-between gap-3">
        <div>
          <div className="text-xl sm:text-2xl font-extrabold tracking-tight text-white">Crash Game — Pro Demo</div>
          <div className="text-xs text-slate-300">Fake coins • Educational only • Pseudo multi-user</div>
        </div>
        <div className="flex items-center gap-2">
          {user ? (
            <>
              <div className="text-slate-200 text-sm">👋 {user.name}</div>
              {auth ? (
                <Button variant="outline" size="sm" onClick={signOutCloud}>Sign out</Button>
              ) : (
                <Button variant="outline" size="sm" onClick={() => setUser(null)}>Sign out</Button>
              )}
            </>
          ) : (
            auth ? (
              <div className="flex items-center gap-2">
                <Button size="sm" onClick={signInGoogle}>Sign in with Google</Button>
                <Button size="sm" variant="secondary" onClick={signInAnon}>Continue as Guest</Button>
              </div>
            ) : (
              <UsernameForm onSubmit={signInLocal} />
            )
          )}
        </div>
      </div>

      <Tabs defaultValue="play" className="mt-4">
        <TabsList className="grid grid-cols-3 w-full sm:w-auto">
          <TabsTrigger value="play">Play</TabsTrigger>
          <TabsTrigger value="leaderboard">Leaderboard</TabsTrigger>
          <TabsTrigger value="about">About</TabsTrigger>
        </TabsList>

        {/* PLAY TAB */}
        <TabsContent value="play" className="mt-4">
          <div className="flex flex-col md:flex-row gap-4 md:gap-6">
            {/* Left: Graph */}
            <div className="flex-1">
              <div className="relative h-64 md:h-80 rounded-2xl bg-slate-900/60 border border-slate-700 overflow-hidden">
                <canvas ref={canvasRef} className="absolute inset-0 w-full h-full" />
                <div className="absolute inset-0 p-3 sm:p-4 flex flex-col justify-between">
                  <div className="flex items-center justify-between text-slate-300 text-xs sm:text-sm">
                    <div>Round #{roundInfo.nonce || 1}</div>
                    <div className="font-mono">Crash at: {roundInfo.crashPoint.toFixed(2)}x</div>
                  </div>
                  <div className="text-center">
                    <AnimatePresence mode="wait">
                      <motion.div
                        key={state === "countdown" ? `cd-${countdown}` : `m-${multiplier}`}
                        initial={{ scale: 0.8, opacity: 0 }}
                        animate={{ scale: 1, opacity: 1 }}
                        exit={{ scale: 0.8, opacity: 0 }}
                        transition={{ type: "spring", stiffness: 220, damping: 16 }}
                        className={`mx-auto inline-flex items-center justify-center rounded-2xl px-5 py-2 font-extrabold tracking-wider text-4xl md:text-6xl ${state === "crashed" ? "bg-red-600/20 text-red-300" : state === "running" ? "bg-emerald-600/20 text-emerald-300" : "bg-sky-600/20 text-sky-300"}`}
                      >
                        {state === "countdown" ? `${countdown}` : state === "crashed" ? "CRASH" : `${multiplier.toFixed(2)}x`}
                      </motion.div>
                    </AnimatePresence>
                  </div>
                  <div className="flex items-center justify-between text-slate-400 text-[10px] sm:text-xs font-mono">
                    <div>serverSeed: {roundInfo.serverSeed.slice(0, 12)}…</div>
                    <div>hash: {roundInfo.hash.slice(0, 12)}…</div>
                  </div>
                </div>
                <ParticleBurst triggerKey={cashoutAt ? lastCashKey : 0} />
              </div>

              <details className="mt-3 bg-slate-900/60 border border-slate-700 rounded-xl p-3 sm:p-4 text-slate-300">
                <summary className="cursor-pointer text-slate-200 font-semibold">Provably-fair (demo) details</summary>
                <div className="mt-3 text-xs sm:text-sm font-mono break-words space-y-1">
                  <div><span className="text-slate-400">serverSeed:</span> {roundInfo.serverSeed}</div>
                  <div><span className="text-slate-400">clientSeed:</span> {roundInfo.clientSeed}</div>
                  <div><span className="text-slate-400">nonce:</span> {roundInfo.nonce}</div>
                  <div><span className="text-slate-400">preimage:</span> {`${roundInfo.serverSeed}:${roundInfo.clientSeed}:${roundInfo.nonce}`}</div>
                  <div><span className="text-slate-400">hash (SHA-256):</span> {roundInfo.hash}</div>
                  <div><span className="text-slate-400">crashPoint (demo):</span> {roundInfo.crashPoint.toFixed(2)}x</div>
                </div>
                <p className="mt-3 text-xs text-amber-300">⚠️ Educational demo only. Not production RNG.</p>
              </details>
            </div>

            {/* Right: Controls */}
            <div className="w-full md:w-72 space-y-3">
              <div className="bg-slate-900/60 border border-slate-700 rounded-2xl p-3 sm:p-4">
                <div className="text-slate-300 text-sm">Balance</div>
                <div className="text-2xl font-extrabold text-white">₹ {formatMoney(balance)}</div>
              </div>

              <div className="bg-slate-900/60 border border-slate-700 rounded-2xl p-3 sm:p-4 space-y-3">
                <label className="text-slate-300 text-sm">Bet amount</label>
                <Input type="number" min={1} step={1} value={bet} onChange={e => setBet(Number(e.target.value))} disabled={!canBet} />
                <div className="flex gap-2">
                  <Button className="flex-1" onClick={() => setBet(b => Math.max(1, Math.floor(b / 2)))} disabled={!canBet}>1/2</Button>
                  <Button className="flex-1" onClick={() => setBet(b => Math.floor(b * 2))} disabled={!canBet}>x2</Button>
                  <Button className="flex-1" onClick={() => setBet(balance)} disabled={!canBet}>Max</Button>
                </div>
                <div className="flex gap-2">
                  <Button variant="secondary" className="flex-1" onClick={placeBet} disabled={!canBet}>Place Bet</Button>
                  <Button className="flex-1" onClick={startRound} disabled={!canStart}>Start</Button>
      
